# 3과목 - 데이터베이스 구축
## 2장. 물리 데이터베이스 설계

---

### 85. 사전 조사 분석
#### 물리 데이터베이스 설계
- 논리적 데이터베이스를 물리적 저장장치에 저장할 수 있는 데이터로 변환하는 과정
- **기본적인 데이터 단위는 저장 레코드 (Stored Record)**
- 물리적 설계 단계에 꼭 포함
    - **저장 레코드의 양식 설계**
    - **레코드 클러스터링의 분석 및 설계**
    - **접근 경로 설계**
- 물리적 설계 시 고려 사항
    - 인덱스 구조 및 레코드 크기
    - 파일에 존재하는 레코드 개수
    - 성능 향상을 위한 개념 스키마의 변경 여부 검토
- **물리적 설계 전에 데이터 명명 규칙, 시스템 자원, 데이터베이스 관리 요소 등 파악**

#### 데이터 명명 규칙 파악
- 물리 데이터 모델에 적용해야 하는 규칙으로 물리 데이터 모델 설계 전 파악
- **물리 데이터베이스 설계와 논리 데이터베이스 설계에 적용되는 명명 규칙은 서로 일관성 유지**
- 데이터 명명 규칙을 통해 중복 구축 방지 가능
- 도메인 및 데이터 사전에 대한 지식 필요
    - 도메인 : 객체에 포함된 속성들의 데이터 타입, 크기 등을 일관성 있게 정의한 것
    - 데이터 사전 : 데이터 속성의 논리명, 물리명, 용어 정의 등을 기술해 놓은 것

#### 시스템 자원 파악
- 데이터베이스 설치에 영향을 미칠 수 있는 물리적인 요소로 사전에 미리 파악해야함
- 시스템 자원
    - 하드웨어 자원
        - 중앙처리장치 : CPU의 성능과 집중적인 부하 발생기간 등을 파악
        - 메모리 : 확보된 자원이나 실질적인 시스템 활용 정도 등을 파악
        - 디스크 : 전체 디스크 크기, 확보된 디스크 자원, 사용 가능한 디스크 공간 등 파악
        - I/O Controller : 입출력 컨트롤러의 성능, 운용의 적절성 파악
        - 네트워크 : 네트워크 처리량, 처리 속도, 동시 접속 가능 정도 등을 파악
    - 운영체제 및 DBMS 버전
    - DBMS 파라미터 정보
        - 시스템별 DBMS 파라미터의 종류 및 관리 대상 등을 파악
    
#### 데이터베이스 관리 요소 파악
- **데이터베이스 관리 요소를 파악한 후 이를 기반으로 데이터베이스 시스템 조사 분석서 작성**
- 시스템 조사 분석서를 기반으로 아래 특성 파악
    - 데이터베이스 구조 : 서버와 데이터베이스 구조 파악
    - 이중화 구성 : 문제 발생에 대비하여 동일한 데이터베이스를 복제하여 관리하는 이중화 구성 파악
    - 분산 데이터베이스 : 데이터 유실을 최소화하며, 데이터 유실 복구에 효과적
    - 접근 제어/접근 통제
    - DB암호화

---

### 86. 데이터베이스 저장 공간 설계
#### 테이블 (Table)
- 데이터베이스의 가장 기본적인 객체로 로우와 컬럼으로 구성
- **논리 설계 단계의 개체에 대응하는 객체**

#### 일반 테이블
- 대부분 DBMS에서 표준 테이블로 사용되는 테이블

#### 클러스터드 인덱스 테이블 (Clustered Index Table)
- **기본키나 인덱스키의 순서에 따라 데이터가 저장되는 테이블**
-  일반 테이블보다 단축된 접근 경로

#### 파티셔닝 테이블 (Partitioning Table)
- **대용량 테이블을 작은 논리적 단위인 파티션으로 나눈 테이블**
- 대용량 데이터를 효과적으로 관리할 수 있지만 파티션 키를 잘못 구성하면 성능 저하 등의 역효과 초래
- 파티셔닝 방식에 따라 구분
    - 범위 분할 / 해시 분할 / 조합 분할

#### 외부 테이블 (External Table)
- 데이터베이스에서 일반 테이블처럼 이용할 수 있는 외부 파일
- 데이터 웨어하우스, ETL 등의 작업에 유용하게 사용

#### 임시 테이블 (Temporary Table)
- **트랜잭션이나 세션별로 데이터를 저장하고 처리할 수 있는 테이블**
- 임시 테이블에 저장된 **데이터는 트랜잭션이 종료되면 삭제**

#### 테이블스페이스 (Tablespace)
- 테이블이 저장되는 논리적인 영역으로, 하나 또는 그 이상의 테이블 저장 가능
- **테이블 저장 시 논리적으로는 테이블스페이스에, 물리적으로는 데이터 파일에 저장**
- 데이터베이스를 테이블, 테이블스페이스, 데이터 파일로 나눠 관리하면 논리적 구성이 물리적 구성에 종속되지 않아 투명성이 보장됨
- 테이블스페이스 설계 시 고려사항
    - 테이블스페이스는 업무별로 구분하여 지정
    - 대용량 테이블은 하나의 테이블스페이스에 독립적으로 저장
    - 테이블과 인덱스는 분리하여 저장

---

### 87. 트랜잭션 분석 / CRUD 분석
#### 트랜잭션 (Transaction) 정의
- **데이터베이스 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위** 또는 **한꺼번에 모두 수행되어야 할 일련의 연산**
- 사용자가 시스템에 대한 서비스 요구 시 시스템이 응답하기 위한 상태 변환 과정의 작업 단위로 사용

#### 트랜잭션의 특성
- 무결성을 보장하기 위해 트랜잭션이 가져야 할 특성 (**ACID**)
    - Atomacity (원자성)
        - **트랜잭션은 데이터베이스에 모두 반영되도록 Commit 되든지 전혀 반영되지 않도록 Rollback 되어야함**
    - Consistency (일관성)
        - 트랜잭션 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변함
        - 시스템이 가지고 있는 고정 요소 : *트랜잭션 수행 전 = 트랜잭션 수행 후*
    - Isolation (독립성)
        - **둘 이상의 트랜잭션이 동시에 실행되는 경우 어느 하나의 트랜잭션 실행 중에 다른 트랜잭션 연산이 끼어들 수 없음**
    - Durability (영속성)
        - 성공적으로 완료된 트랜잭션 결과는 영구적으로 반영되어야함

#### CRUD 분석
- 데이터베이스 테이블에 변화를 주는 CRUD 연산에 대해 CRUD 매트리스를 작성하여 분석하는 것
- 테이블에 발생되는 트랜잭션의 주기별 발생 횟수를 파악하고 저장되는 데이터 양 유추 가능
- 많은 트랜잭션이 몰리는 테이블 파악 가능
- 외부 프로세스 트랜잭션의 부하가 집중되는 데이터베이스 채널을 분산시킴으로써 타임아웃 오류 방지

#### CRUD 매트릭스
- 행에는 프로세스를, 열에는 테이블을, 행과 열이 만나는 위치에는 프로세스가 테이블에 발생시키는 변화를 표시
- CRUD 매트릭스를 통해 트랜잭션이 테이블에 수행하는 작업을 검증
- *C > D > U > R* 우선순위를 적용하여 한 가지만 표기

#### 트랜잭션 분석서
- 단위 프로세스 : 업무를 발생시키는 가장 작은 단위의 프로세스
- CRUD 연산
- 테이블명, 컬럼명 : 프로세스가 접근하는 테이블명 기록
- 테이블 참조 횟수
- 트랜잭션 수
- 발생 주기

---

### 88. 인덱스 설계
#### 인덱스 (Index)의 개념
- **인덱스는 레코드를 빠르게 접근하기 위해 *(키 값, 포인터)* 쌍으로 구성되는 데이터 구조**
- 인덱스는 데이터가 저장된 물리적 구조와 밀접한 관계
- 인덱스가 없으면 특정한 값을 찾기 위해 모든 데이터를 확인하는 *TABLE SCAN* 발생
- 기본 인덱스 : 기본키를 위한 인덱스
- 보조 인덱스 : 기본 인덱스가 아닌 인덱스들
- 클러스터드 인덱스 (Clustered Index)
    - **레코드 물리적 순서가 인덱스의 엔트리 순서와 일치하게 유지되도록 구성하는 인덱스**
    - 데이터 삽입, 삭제 발생 시 순서를 유지하기 위해 데이터 재정렬
    - **한 개의 릴레이션에 하나의 인덱스만 생성 가능**
- 넌클러스터드 인덱스 (Non-Clustered Index)
    - **인덱스 키 값만 정렬되어 있을 뿐 실제 데이터는 정렬되지 않는 방식**
    - 클러스터드 인덱스에 비해 다소 떨어지는 검색 속도
    - **한 개의 릴레이션에 여러 개의 인덱스 생성 가능**

#### 트리 기반 인덱스
- 인덱스를 저장하는 블록들이 트리 구조를 이루고 있는 것
- *B 트리 인덱스*
    - 루트 노드에서 하위 노드로 키 값의 크기를 비교해 나가면서 **단말 노드에서 찾고자 하는 데이터 검색**
    - 모든 리프 노드는 같은 레벨에 있음
- *B+ 트리 인덱스*
    - 단말 노드가 아닌 노드로 구성된 인덱스 세트와 단말 노드로만 구성된 순차 세트로 구분
    - **인덱스 세트에 있는 노드들은 단말 노드에 있는 키 값을 찾아갈 수 있는 경로로만 제공**
    - **순차 세트에 있는 단말 노드가 해당 데이터 레코드의 주소를 가리킴**

#### 비트맵 인덱스
- 인덱스 컬럼의 데이터를 0 또는 1로 변환하여 인덱스키로 사용
- 목적 : 키 값을 포함하는 로우의 주소를 제공하는 것
- 데이터가 Bit로 구성되어 있기 때문에 저장 공간이 작고, 압축 효율이 좋음

#### 함수 기반 인덱스
- 컬럼값 대신 컬럼에 특정 함수나 수식을 적용하여 산출된 값을 사용
- 데이터를 입력하거나 수정할 때 함수를 적용해야 하므로 부하 발생 가능

#### 비트맵 조인 인덱스
- 다수의 조인된 객체로 구성된 인덱스

#### 도메인 인덱스
- **개발자가 필요한 인덱스르 직접 만들어 사용하는 것**

#### 인덱스 설계
1. 인덱스의 대상 테이블이나 컬럼 선정
2. 인덱스의 효율성을 검토하여 인덱스 최적화 수행
3. 인덱스 정의서 작성

---

### 89. 뷰 (View) 설계
#### 뷰 (View) 개요
- 뷰는 **사용자에게 접근 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된 가상 테이블**
- 저장장치 내에 물리적으로 존재하지 않지만, 사용자에게는 있는 것처럼 간주
- 조인문의 사용 최소화로 사용상 편의성을 최대화

#### 뷰의 특징
- 뷰는 기본 테이블로부터 유도된 테이블이므로 같은 형태의 구조를 사용
- 데이터의 논리적 독립성 제공
- 뷰를 통해서만 데이터에 접근하게 하면 뷰에 나타나지 않는 데이터를 안전하게 보호하는 효율적인 기법으로 사용 가능

#### 뷰의 장단점
- 장점
    - 논리적 데이터 독립성을 제공
    - 사용자 데이터 관리를 간단하게 해주고, 접근 제어를 통한 자동 보안 제공
- 단점
    - 뷰의 정의를 변경할 수 없음
    - 삽입, 삭제, 갱신 연상에 제약이 따름

#### 뷰 설계 순서
1. 대상 테이블 선정
2. 대상 컬럼 선정 : 보안을 유지해야 하는 컬럼은 주의하여 선별
3. 뷰 정의서 작성

---

### 90. 클러스터 설계
#### 클러스터 (Cluster) 개요
- 데이터 저장 시 액세스 효율을 향상시키기 위해 **동일한 성격의 데이터를 동일한 데이터 블록에 저장**하는 물리적 저장 방법
- **클러스터링키로 지정된 컬럼 값의 순서대로 저장**되고, 여러 테이블이 하나의 클러스터에 저장됨

#### 클러스터의 특징
- 클러스터링된 테이블은 데이터 조회 속도는 향상시키지만 C, U, D 연산에 대한 성능은 저하
- 데이터 분포도가 넓을수록 유리 (**인덱스와 반대**)
- 대용량을 처리하는 트랜잭션은 전체 테이블을 스캔하는 일이 잦으므로 클러스터링 하지 않는 것이 좋음
- **파티셔닝된 테이블에는 클러스터링을 할 수 없음**
- 클러스터링된 테이블에 클러스터드 인덱스를 생성하면 접근 성능이 향상

#### 클러스터 대상 테이블
- 분포도가 넓은 테이블
- 대량의 범위를 자주 조회하는 테이블
- 입력, 수정, 삭제가 자주 발생하지 않는 테이블
- 자주 조인되어 사용되는 테이블

---

### 91. 파티션 설계
#### 파티션 (Partition)의 개요
- 파티션은 대용량 테이블이나 인덱스를 작은 논리적 단위인 파티션으로 나누는 것
- 파티셔닝하면 **파티션키 또는 인덱스키에 따라 물리적으로 별도의 공간에 데이터가 저장됨**
- 데이터 처리는 테이블 단위로, 데이터 저장은 파티션별로 수행

#### 파티션의 장단점
- 장점
    - 데이터 접근 시 액세스 범위를 줄여 쿼리 성능이 향상
    - 파티션별로 데이터가 분산되어 디스크 성능 향상
    - 시스템 장애 시 데이터 손상 정도 최소화
- 단점
    - 하나의 테이블을 세분화하여 관리하므로 세심한 관리 요구
    - 테이블간 조인에 대한 비용 증가

#### 파티션의 종류
- 범위 분할 (Range Partitioning)
    - 지정한 열의 값을 기준으로 분할
- 해시 분할 (Hash Partitioning)
    - 해시 함수를 적용한 결과 값에 따라 데이터 분할
    - **특정 파티션에 데이터가 집중되는 범위 분할의 단점 보완**
    - 데이터가 고른 컬럼에 효과적
- 조합 분할 (Composite Partitioning)
    - **범위 분할로 분할한 다음 해시 함수를 적용하여 다시 분할하는 방식**

#### 인덱스 파티션
- 인덱스 파티션은 파티션된 테이블의 데이터를 관리하기 위해 인덱스를 나눈 것
- *파티션된 테이블의 종속 여부에 따라*
    - Local Partitioned Index
        - 테이블 파티션과 인덱스 파티션이 1:1 대응되도록 파티셔닝
    - Global Partitioned Index
        - 테이블 파티션과 인덱스 파티션이 독립적으로 구성되도록 파티셔닝
- *파티션된 컬럼의 위치에 따라*
    - Prefixed Partitioned Index
        - 인덱스 파티션키와 인덱스 첫 번째 컬럼이 같음
    - Non-Prefixed Partitioned Index
        - 인덱스 파티션키와 인덱스 첫 번째 컬럼이 다름

---

### 93. 분산 데이터베이스 설계
#### 분산 데이터베이스 정의
- 논리적으로는 하나의 시스템에 속하지만 물리적으로는 여러 개의 컴퓨터 사이트에 분산되어 있는 데이터베이스

#### 분산 데이터베이스의 구성 요소
- 분산 처리기 : 자체적으로 처리 능력을 가지며, 지리적으로 분산되어 있는 컴퓨터 시스템
- 분산 데이터베이스 : 지리적으로 분산되어 있는 데이터베이스
- 통신 네트워크 : 분산 처리기들을 통신망으로 연결한 통신 네트워크

#### 분산 데이터베이스의 목표
- **위치 투명성** (Location Transparency)
    - 데이터베이스의 실제 위치를 알 필요 없이 논리적인 명칭만으로 액세스할 수 있음
- **중복 투명성** (Replication Transparency)
    - 동일 데이터가 여러 곳에 중복되어 있더라도 사용자는 하나의 데이터만 존재하는 것처럼 사용
- **병행 투명성** (Concurrency Transparency)
    - 다수의 트랜잭션들이 동시에 실현되더라도 그 트랜잭션의 결과는 영향을 받지 않음
- **장애 투명성** (Failure Transparency)
    - 트랜잭션, DBMS, 네트워크 장애에도 불구하고 트랜잭션을 정확하게 처리

#### 분산 데이터베이스의 장단점
- 장점
    - 지역 자치성이 높고 분산 제어가 가능
    - 신뢰성 및 가용성이 높음
    - 시스템 성능 향상
- 단점
    - DBMS가 수행할 기능이 복잡
    - 데이터베이스 설계가 어렵고, 처리 비용 증가

#### 분산 데이터베이스 설계
- 목적 : 애플리케이션이나 사용자가 분산되어 저장된 데이터에 접근하게 하는 것
- **잘못 설계된 분산 데이터베이스는 복잡성 증가, 응답 속도 저하, 비용 증가 등의 문제 발생**
- 분산 설계 방법
    - 테이블 위치 분산
    - 분할
    - 할당

#### 테이블 위치 분산
- **테이블을 각기 다른 서버에 분산시켜 배치하는 방법**
- 테이블 구조를 변경하지 않으며, 다른 테이블과 중복되지 않게 배치

#### 분할 (Fragment)
- **테이블의 데이터를 분할하여 분산시키는 것**
- 분할 규칙
    - 완전성 : 전체 데이터를 대상으로 분할
    - 재구성 : 분할된 데이터는 연산을 활용하여 본래의 데이터로 재구성할 수 있어야함
    - 상호 중첩 배제 : 분할된 데이터는 서로 다른 분할 항목에 속하지 않아야함
- 주요 분할 방법
    - 수평 분할 : 행 단위로 분할
    - 수직 분할 : 열 단위로 분할

#### 할당 (Allocation)
- **동일한 분할을 여러 개의 서버에 생성하는 분산 방법**
- *비중복 할당 방식*
    - 분산 데이터베이스의 단일 노드에서만 분할이 존재하도록 하는 방식
- *중복 할당 방식*
    - **동일한 테이블을 다른 서버에 복제하는 방식**

---

### 94. 데이터베이스 이중화 / 서버 클러스터링
#### 데이터베이스 이중화 (Database Replication)
- 시스템 오류로 인한 데이터베이스 서비스 중단이나 물리적 손상 발생 시 이를 복구하기 위해 **동일한 데이터베이스를 복제하여 관리하는 것**
- 데이터베이스 부하를 줄일 수 있고, 손쉽게 백업 서버를 운영할 수 있음

#### 데이터베이스 이중화의 분류
- Eager 기법
    - **트랜잭션 중** 데이터 변경 발생 시 이중화된 모든 데이터베이스에 즉시 전달하여 **변경 내용이 바로 적용되도록 하는 기법**
- Lazy 기법
    - **트랜잭션이 종료**되면 변경 사실을 각 데이터베이스에 전달하는 기법

#### 데이터베이스 이중화 구성 방법
- 활동-대기 (Active-Standby) 방법
    - 한 DB가 활성 상태로 서비스 중이면 다른 DB는 대기하고 있다가 활성 DB에 장애 발생 시 대기 상태에 있던 DB가 자동으로 모든 서비스를 대신 수행
- 활동-활동 (Active-Active) 방법
    - 두 개의 DB가 서로 다른 서비스를 제공하다가 한쪽 DB에 문제 발생 시 나머지 DB가 서비스 제공
    - 두 DB 모두 처리하기 때문에 처리율이 높지만 구성 방법 및 설정이 복잡

#### 클러스터링 (Clustering)
- **두 대 이상의 서버를 하나의 서버처럼 운영하는 기술**
- 서버 이중화 및 공유 스토리지를 사용하여 서버의 고가용성 제공
- *고가용성 클러스터링*
    - **하나의 서버에 장애가 발생하면 다른 서버가 받아 처리하여 서비스 중단을 방지하는 방법**
- *병렬 클러스터링*
    - **전체 처리율을 높이기 위해 하나의 작업을 여러 서버에서 분산하여 처리하는 방식**

---

### 95. 데이터베이스 보안 / 암호화
#### 데이터베이스 보안의 개요
- 권한이 없는 사용자가 액세스하는 것을 금지하기 위해 사용되는 기술
- **무결성은 권한이 있는 사용자로부터, 보안은 권한이 없는 사용자로부터 데이터베이스를 보호하는 것**

#### 암호화 (Encryption)
- 암호화 과정 : 평문을 암호문으로 바꾸는 과정
- 복호화 과정 : 암호문을 원래 평문으로 바꾸는 과정

#### 개인키 암호 방식 (Private Key Encryption) = 비밀키 암호 방식
- **동일한 키로 데이터를 암호화하고 복호화**
- 비밀키는 데이터베이스 사용 권한이 있는 사용자만 나누어 가짐
- 대칭 암호화 방식
- *ex) 전위 기법, 대체 기법, 대수 기법, DES*

#### 공개키 암호 방식 (Public Key Encryption)
- **서로 다른 키로 데이터를 암호화하고 복호화**
- 공개키는 암호화할 때 사용하고, 비밀키는 복호화할 때 사용
- 비대칭 암호화 방식
- *ex) RSA*

---

### 96. 데이터베이스 보안 - 접근통제
#### 접근통제
- 접근통제는 데이터가 저장된 객체와 사용하려는 주체 사이 정보 흐름을 제한하는 것
- 자원의 불법적인 접근 및 파괴 예방
- 접근통제 기술
    - 임의 접근통제 (DAC, Discretionary Access Control)
        - **데이터에 접근하는 사용자 신원에 따라 접근 권한 부여**
        - 주체가 접근통제 권한을 지정하고 제어할 수 있음
        - *ex) GRANT / REVOKE*
    - 강제 접근통제 (MAC, Mandatory Access Control)
        - **주체와 객체의 등급을 비교하여 접근 권한 부여**
        - 제3자가 접근통제 권한을 지정
- 접근통제 3요소
    1. 접근통제 정책
    2. 접근통제 매커니즘
    3. 접근통제 보안모델

#### 접근통제 정책
- 어떤 주체가 언제, 어디서, 어떤 객체에게, 어떤 행위에 대한 허용 여부를 정의하는 것
- *신분 기반 정책*
- *규칙 기반 정책*
- *역할 기반 정책*

#### 접근통제 매커니즘
- 정의된 접근통제 정책을 구현하는 기술적인 방법
- *접근통제 목록* : 특정 객체에 대해 어떤 주체가 어떤 행위를 할 수 있는지 기록한 목록
- *능력 리스트* : 주체에게 허가된 자원 및 권한을 기록한 목록
- *보안 등급* : 주체나 객체 등에 부여된 보안 속성의 집합
- *패스워드* : 주체가 자신임을 증명할 때 사용하는 인증 방법
- *암호화* : 무단 도용을 방지하기 위해 사용

#### 접근통제 보안 모델
- 기밀성 모델
    - 군사적인 목적으로 개발된 모델로, 기밀성 보장이 최우선
    - 군대 시스템 등 특수 환경에서 주로 사용
- 무결성 모델
    - 기밀성 모델에서 발생하는 불법적인 정보 변경을 방지하기 위해 무결성을 기반으로 개발된 모델
    - 데이터 일관성 유지에 중점
- 접근통제 모델
    - 접근통제 매커니즘을 보안 모델로 발전시킨 것

#### 접근통제 조건
- 값 종속 통제 (Value- Dependent Control)
    - 객체에 저장된 값에 따라 다르게 접근통제를 허용해야 하는 경우에 사용
- 다중 사용자 통제 (Multi-User Control)
    - 다수의 사용자가 동시에 접근을 요구하는 경우에 사용
- 컨텍스트 기반 통제 (Context-Based Control)
    - 다른 보안 정책과 결합하여 보안 시스템 취약점을 보완할 때 사용

---

### 97. 데이터베이스 백업
#### 로그 파일
- 데이터베이스 처리 내용이나 이용 상황 등 상태 변화를 **시간의 흐름에 따라 모두 기록한 파일**
- 데이터베이스 복구를 위해 필요한 가장 기본적인 자료

#### 데이터베이스 복구 알고리즘
- *NO-UNDO/REDO*
    - 데이터베이스 버퍼 내용을 비동기적으로 갱신한 경우의 복구 알고리즘
- *UNDO/NO-REDO*
    - 데이터베이스 버퍼 내용을 동기적으로 갱신한 경우의 복구 알고리즘
- *UNDO/REDO*
    - 데이터베이스 버퍼 내용을 동기/비동기적으로 갱신한 경우의 복구 알고리즘
- *NO-UNDO/NO-REDO*
    - 데이터베이프 버퍼 내용을 동기적으로 저장 매체에 기록하지만 데이터베이스와는 다른 영역에 기록한 경우의 복구 알고리즘
- 동기적 갱신 : 트랜잭션이 완료되기 전에 버퍼 내용을 저장매체에 동시적으로 기록하는 것
- 비동기적 갱신 : 트랜잭션이 완료된 내용을 시간 차이를 두고 저장매체에 기록하는 것
- UNDO : 기록한 내용을 취소함
- REDO : 트랜잭션 내용을 다시 실행함

#### 백업종류
- 물리 백업
    - 데이터베이스 파일을 백업하는 방법
    - 백업 속도가 빠르고 작업이 단순하지만 문제 발생 시 원인 파악이 어려움
    - **완전 복구 가능**
- 논리 백업 
    - DB 내 논리적 객체들을 백업하는 방법
    - 복원 시 데이터 손상을 막을 수 있지만 많은 시간 소요

---

### 98. 스토리지
#### 스토리지 (Storage)의 개요
- 스토리지는 **대용량 데이터를 저장하기 위해 서버와 저장장치를 연결하는 기술**
- 종류
    - DAS / NAS / SAN

#### DAS (Direct Attached Storage)
- **서버와 저장장치를 전용 케이블로 직접 연결하는 방식** (컴퓨터에 외장하드를 연결하는 것)
- 서버가 저장장치를 관리
- 속도가 빠르고 초기 구축 비용이 저렴
- 직접 연결하기 때문에 다른 서버에서 접근할 수 없고 파일 공유 불가능

#### NAS (Network Attached Storage)
- **서버와 저장장치를 네트워크를 통해 연결하는 방식**
- NAS Storage가 내장된 저장장치를 직접 관리
- 다른 서버에서도 스토리지에 접근할 수 있어 파일 공유가 가능
- DAS에 비해 확장성 및 유연성이 우수하나 접속 증가 시 성능 저하

#### SAN (Storage Area Network)
- DAS의 빠른 처리와 NAS의 파일 공유 장점을 혼합한 방식
- **서버와 저장장치를 연결하는 전용 네트워크를 별도로 구성하는 방식**
- 파이버 채널(FC) 스위치를 이용하여 네트워크 구성

---

#### 참고
- [시나공 정보처리기사 필기 책](https://book.naver.com/bookdb/book_detail.nhn?bid=15766742)
