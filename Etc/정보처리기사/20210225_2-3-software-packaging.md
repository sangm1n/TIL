# 2과목 - 소프트웨어 개발
## 3장. 제품 소프트웨어 패키징

---

### 41. 소프트웨어 패키징
#### 소프트웨어 패키징의 개요
- 소프트웨어 패키징이란 **모듈별로 생성한 실행 파일들을 묶어 배포용 설치 파일을 만드는 것**
- 사용자 중심으로 진행하며 향후 관리를 고려하여 모듈화하여 패키징
- 다양한 환경에서 쉽게 사용할 수 있도록 일반적인 배포 형태로 패키징

#### 패키징 시 고려사항
- 사용자 시스템 환경에 필요한 최소 환경 정의
- UI는 시각적인 자료화 함께 제공하고 메뉴얼과 일치시켜 패키징
- 단순히 패키징하여 배포하는 것으로 끝나는 것이 하드웨어와 함께 관리될 수 있도록 *Managed Service* 형태로 제공
    - Managed Service : 고객이 사용 중인 소프트웨어를 24시간 모니터링 (문제 발생 시 바로 출동)

#### 패키징 작업 순서
- **개발 과정**에서 주기별로 패키징한 결과물은 **테스트 서버**에 배포
- 최종 패키징한 결과물은 고객이 사용할 수 있도록 온라인 또는 오프라인으로 배포
    - 온라인 배포 : 별도로 마련한 운영 서버에 배포 파일 등록
    - 오프라인 배포 : CD-ROM이나 USB 등에 담아 배포
1. 기능 식별 : 작성된 코드의 기능 확인
2. 모듈화 : 확인된 기능 단위로 코드 분류
3. 빌드 진행 : 모듈 단위별로 실행 파일 만듦
4. 사용자 환경 분석 : 소프트웨어가 사용될 최소 운영 환경 정의
5. 패키징 및 적용 시험 : 빌드된 실행 파일을 배포용 파일 형식으로 패키징
6. 패키징 변경 개선 : 확인된 불편 사항을 반영하기 위해 피키징 변경 진행
7. 배포 : 오류 발생 시 개발자에세 수정 요청

---

### 42. 릴리즈 노트 작성
#### 릴리즈 노트 (Release Note)의 개요
- 릴리즈 노트는 개발 과정에서 정리된 릴리즈 정보를 고객과 공유하기 위한 문서
- 릴리즈 노트는 소프트웨어 초기 배포 시 또는 추가 배포 시 제공

#### 릴리즈 노트 초기 버전 작성 시 고려사항
- 정확한 정보를 기반으로 **개발팀에서 직접 현재 시제로 작성**
- 신규 소스, 빌드 등의 이력 뿐만 아니라 변경 및 개선된 항목에 대한 정보들도 포함

#### 릴리즈 노트 추가 버전 작성 시 고려사항
- 테스트 과정에서 베타 버전이 출시되거나 특수한 상황이 발생하는 경우 릴리즈 노트 추가 작성
- 오류로 인한 **긴급 수정의 경우** 릴리즈 버전을 출시하고, **모든 수정된 내용을 담아 릴리즈 노트 작성**

#### 릴리즈 노트 작성 순서
1. 모듈 식별 : 모듈별 빌드 수행 후 릴리즈 노트에 작성될 내용 확인
2. 릴리즈 정보 확인
3. 릴리즈 노트 개요 작성 : 변경사항 전체에 대한 간략한 내용 작성
4. 영향도 체크 : 해당 릴리즈 버전에서의 기능 변화가 다른 소프트웨어에 미칠 수 있는 영향 기술
5. 정식 릴리즈 노트 작성
6. 추가 개선 항목 식별

---

### 43. 디지털 저작권 관리 (DRM)
#### 저작권의 개요
- 저작권이란 저작물에 대하여 창작자가 가지는 배타적 독점적 권리

#### 디지털 저작권 관리 (DRM, Digital Right Management)의 개요
- DRM은 **저작권자가 배포한 디지털 콘텐츠가 의도한 용도로만 사용되게 하는 디지털 콘텐츠 관리 및 보호 기술**
    - 크기가 작은 경우 (음원이나 문서) : 사용자가 콘텐츠를 요청하는 시점에서 **실시간으로 패키징**
    - 크기가 큰 경우 : **미리 패키징한 후 배포**
- 사용자가 콘텐츠를 사용하기 위해서는 클리어링 하우스에 등록된 라이스 전보를 통해 사용자 인증을 받아야함

#### 디지털 저작권 관리의 흐름도
![image](https://user-images.githubusercontent.com/46131688/108856006-f1a9ae80-762c-11eb-966c-0fec532f214e.png)

- 클리어링 하우스(Clearing House) : 저작권료의 정산 및 분배 수행
- 콘텐츠 제공자 (Contents Provider) : 콘텐츠를 제공하는 저작권자
    - 패키저 (Packager) : 콘텐츠를 메타 데이터와 함께 배포 가능한 형태로 묶어 암호화
- 콘텐츠 분배자 (Contents Distributor) : 암호화된 콘텐츠 유통
- 콘텐츠 소비자 (Customer) : 콘텐츠를 구매해서 사용하는 주체
    - DRM 컨트롤러 (DRM Controller) : 배포된 콘텐츠의 이용 권한을 통제
    - 보안 컨테이너 (Security Container) : 콘텐츠 원본을 안전하게 유통하기 위한 보안 장치

#### 디지털 저작권 관리의 기술 요소
- 암호화 (Encryption) : 콘텐츠를 암호화하고 전자 서명을 할 수 있는 기술
- 키 관리 (Key Management) : 콘텐츠를 암호화한 키에 대한 저장 및 분배 기술
- 암호화 파일 생성 (Packager) : 암호화된 콘텐츠로 생성하기 위한 기술
- 식별 기술 (Identification) : 콘텐츠에 대한 식별 체계 표현 기술
- 저작권 표현 (Right Expression) : 라이선스의 내용 표현 기술
- 정책 관리 (Policy Management) : 크랙에 의한 콘텐츠 사용 방지 기술
- 인증 (Authentication) : 사용자 인증 기술

---

### 44. 소프트웨어 설치 매뉴얼 작성
#### 소프트웨어 설치 매뉴얼의 개요
- 설치 매뉴얼은 사용자 기준으로 작성
- 설치 시작부터 완료할 때까지의 **전 과정을 빠짐없이 작성**

#### 설치 매뉴얼 작성 순서
1. 기능 식별 : 개발 목적과 주요 기능을 흐름 순으로 정리
2. UI 분류 : 설치 매뉴얼을 작성할 순서대로 UI 분류
3. 설치 및 백업 파일 확인 : 개별적인 기능을 확인하여 기록
4. Uninstall 절차 확인 : 직접 Uninstall 수행하면서 단계별로 기록
5. 이상 Case 확인 : 설치 과정에서 발생할 수 있는 다양한 Case에 대한 대처법 기록
6. 최종 매뉴얼 적용

---

### 46. 소프트웨어 버전 등록
#### 소프트웨어 패키징의 형상 관리
- **형상 관리 (SCM, Software Configuration Management)는 소프트웨어의 변경 사항을 관리하기 위해 개발된 일련의 활동**
- 소프트웨어 개발의 전 단계에 적용되는 활동이며 유지보수 단계에서도 수행
- 형상 관리는 전체 개발 비용을 줄이고 여러 방해 요인을 최소화하는 것이 목적

#### 형상 관리의 중요성
- 지속적인 소프트웨어의 변경 사항을 추적 및 통제 가능
- 소프트웨어에 대한 무절제한 변경 방지
- 소프트웨어는 형태가 없어 가시성이 결핍되므로 **진행 정도를 확인하기 위한 기준으로 사용**

#### 형상 관리 기능
- 형상 식별 : 형상 관리 대상에 이름과 번호를 부여하고 계층 구조로 구분
- 버전 제어 : 다른 버전의 형상 항목을 관리
- 형상 통제 (변경 관리) : 변경 요구를 검토하여 현재의 기준선이 잘 반영될 수 있도록 조정
- 형상 감사 : 기준선의 무결성을 평가하기 위해 공식적으로 승인하는 작업
- 형상 기록 (상태 보고) : 보고서 작성

#### 소프트웨어의 버전 등록 관련 주요 용어
- 저장소 (Repository) : 최신 버전의 파일들과 변경 내역에 대한 정보들이 저장된 곳
- 가져오기 (Import) : 아무것도 없는 저장소에 처음으로 파일을 복사
- 체크아웃 (Check-Out) : 프로그램 수정을 위해 **저장소에서 파일을 받아옴**
- 체크인 (Check-In) : 체크아웃 한 파일을 수정한 후 **저장소 파일을 새로운 버전으로 갱신**
- 커밋 (Commit) : 체크인 수행 시 수정한 후 갱신 완료
- 동기화 (Update) : 저장소에 있는 최신 버전으로 자신의 작업 공간 동기화

#### 소프트웨어 버전 등록 과정
1. 가져오기 (Import)
2. 인출 (Check-Out)
3. 예치 (Commit)
4. 동기화 (Update)
5. 차이 (Diff)

---

### 47. 소프트웨어 버전 관리 도구
#### 공유 폴더 방식
- 공유 폴더 방식은 **버전 관리 자료가 로컬 컴퓨터의 공유 폴더에 저장되어 관리**
- 개발자들은 개발이 완료된 파일을 약속된 공유 폴더에 매일 복사
- 담당자는 파일을 자기 PC로 복사하여 이상 유무 확인
- 파일의 변경 사항을 데이터베이스에 기록
- *ex) SCCS, RCS, PVCS 등*

#### 클라이언트/서버 방식
- 버전 관리 자료가 서버에 저장되어 관리되는 방식
- 서버 자료를 개발자별로 자신의 PC로 복사하여 작업
- **모든 버전 관리는 서버에서 수행**
- *ex) CVS, SVN, CVSNT 등*

#### 분산 저장소 방식
- 하나의 원격 저장소와 분산된 개발자 PC의 로컬 저장소에 함께 저장되어 관리
- 로컬에서 버전 관리가 가능하므로 원격 저장소에 문제가 생겨도 로컬 저장소 자료를 이용하여 작업
- *ex) Git, GNU arch, Bazaar 등*

#### Subversion (SVN)
- Subversion은 CVS를 개선한 것으로, 서버에는 최신 버전의 파일들과 변경 내역이 관리 (**클라이언트/서버 방식**)
- 모든 개발 작업은 *trunk* 디렉토리에서 수행되며, 추가 작업은 *branches* 디렉토리 안에 별도의 디렉토리를 만들어 작업 후 병합
- 커밋할 때마다 revision (커밋 버전) 1씩 증가
- 주요 명령어
    - add / commit / update (=pull) / checkout (=push)
    - import : 아무것도 없는 서버 저장소에 맨 처음 소스 파일을 저장하는 명령어 (**한 번만 사용**)
    - export : 버전 관리 정보를 제외한 순수 소스 파일만을 서버에서 받아옴

#### Git
- **분산 버전 관리 시스템**으로 2개의 저장소 (로컬/원격 저장소) 존재
    - 로컬 저장소 : 개발자들이 실제 개발을 진행하는 장소
    - 원격 저장소 : 협업을 위해 버전을 공동 관리하는 곳
- 로컬에서 버전 관리가 진행되기 때문에 신속하게 처리 가능
- 주요 명령어
    - add / commit / push / pull / merge / fork
    - branch : 새로운 브랜치 생성
    - checkout : 지정한 브랜치로 이동
    - init : 로컬 저장소 생성
    - fetch : **원격 저장소의 변경 이력만을 로컬 저장소에 반영**
    - clone : **원격 저장소의 전체 내용을 로컬 저장소로 복제**

---

### 48. 빌드 자동화 도구
#### 빌드 자동화 도구의 개념
- 빌드란 소스 파일들을 컴파일한 후 여러 개의 모듈을 묶어 **실행 파일로 만드는 것**
- 빌드를 포함하여 테스트 및 배포를 자동화하는 도구가 빌드 자동화 도구
- *ex) Jenkins, Gradle, Mave, Ant*

#### Jenkins
- JAVA 기반의 오픈 소스 형태로 가장 많이 사용되는 빌드 자동화 도구
- 서블릿 컨테이너에서 실행되는 서버 기반 도구
- 대부분의 형상 관리 도구와 연동 가능

#### Gradle
- Groovy를 기반으로 한 오픈 소스 형태의 자동화 도구
- 실행할 처리 명령들을 모아 태스크로 만든 후 태스크 단위로 실행

---

#### 참고
- [시나공 정보처리기사 필기 책](https://book.naver.com/bookdb/book_detail.nhn?bid=15766742)
