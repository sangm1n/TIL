# 4과목 - 프로그래밍 언어 활용
## 3장. 응용 SW 기초 기술 활용

---

### 141. 운영체제의 개념
#### 운영체제 (OS, Operating System)의 정의
- 운영체제는 **컴퓨터 시스템 자원을 효율적으로 관리하며, 사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있는 환경을 제공**
- **사용자와 하드웨어 간의 인터페이스로서 동작하는 시스템 소프트웨어**

#### 운영체제의 목적
- 처리 능력 향상, 사용 가능도 향상, 신뢰도 향상, 반환 시간 단축
    - 처리 능력 (Throughput)
        - **일정 시간 내 시스템이 처리하는 일의 양**
    - 반환 시간 (Turn Around Time)
        - **시스템에 작업을 의뢰한 시간부터 처리가 완료될 때까지 걸린 시간**
    - 사용 가능도 (Availability)
        - **시스템을 사용할 필요가 있을 때 즉시 사용 가능한 정도**
    - 신뢰도 (Reliability)
        - **시스템이 주어진 문제를 정확하게 해결하는 정도**

#### 운영체제의 기능
- 프로세서, 기억장치, 입출력장치, 파일 및 정보 등의 자원 관리
- 효율적인 자원 관리를 위해 스케줄링 기능 제공
    - 스케줄링 (Scheduling) : **어떤 자원을 누가, 언제, 어떤 방식으로 사용할지를 결정해주는 것**
- 사용자와 시스템 간 편리한 인터페이스를 제공하고, 시스템의 각종 하드웨어와 네트워크 관리
- 데이터를 관리하고, 데이터 및 자원의 공유 기능 제공
- 시스템 오류를 검사하고 복구

#### 운영체제의 주요 자원 관리
- 프로세스 관리 : 프로세스 스케줄링 및 생성과 제거, 시작과 정지 등의 기능 담당
- 기억장치 관리 : 프로세스에게 메모리 할당 및 회수 관리 담당
- 주변장치 관리 : 입출력장치 스케줄링 및 전반적인 관리 담당
- 파일 관리 : 파일 생성과 삭제, 변경, 유지 등의 관리 담당

#### 운영체제의 조류
- 단일 작업 처리 시스템 (Single Tasking System)
    - 컴퓨터 시스템을 한 개의 작업이 독점하여 사용하는 방식
    - *ex) MS-DOS*
- 다중 작업 처리 시스템 (Multi-Tasking System)
    - 여러 개의 프로그램을 열어 두고 다양한 작업을 동시에 진행하는 방식
    - *ex) Windows / UNIX / LINUX / MacOS 등*

---

### 142. Windows
#### Windows의 개요
- Windows는 1990년대 마이크로소프트 사가 개발한 운영체제
- 주요 특징
    - GUI / 선점형 멀티태스킹 / OLE / PnP

#### 그래픽 사용자 인터페이스 (GUI, Graphic User Interface)
- 키보드로 명령어를 직접 입력하지 않고, 마우스로 모든 작업을 수행하는 방식

#### 선점형 멀티태스킹 (Preemptive Multi-Tasking)
- 멀티태스킹을 하면서 응용 프로그램 실행 중 문제가 발생하면 해당 프로그램을 강제 종료시키고 모든 시스템 자원을 반환하는 방식
- **하나의 응용 프로그램이 CPU 독점하는 것을 방지하여 시스템 다운 현상 없이 안정적인 작업 가능**

#### PnP (Plug and Play, 자동 감지 기능)
- 컴퓨터 시스템에 프린터나 사운드 카드 등 하드웨어 설치 시 필요한 시스템 환경을 운영체제가 자동으로 구성해주는 기능

#### OLE (Object Linking and Embedding)
- 다른 응용 프로그램에서 작성된 문자나 그림 등의 객체(Object)를 현재 작성 중인 문서에 자유롭게 연결(Linking)하거나 삽입(Embedding)하여 편집할 수 있게 하는 기능

#### Single-User 시스템
- 컴퓨터 한 대를 한 사람만이 독점해서 사용

---

### 143. UNIX / LINUX / MacOS
#### UNIX의 개요 및 특징
- 1960년대 AT&T 벨 연구소, MIT, General Electric이 공동 개발한 운영체제
- **시분할 시스템 (Time Sharing System)을 위해 설계된 대화식 운영체제**
- 대부분 C 언어로 작성되어 있어 이식성과 호환성이 높음
- 다중 사용자 (Multi-User), 다중 작업 (Multi-Tasking) 지원
- 많은 네트워킹 기능을 제공하므로 **통신망 관리용 운영체제로 적합**
- 트리 구조의 파일 시스템

#### UNIX 시스템의 구성
![image](https://user-images.githubusercontent.com/46131688/109522250-6aa77b00-7af1-11eb-8421-66e40d8c2eb5.png)

- 커널 (Kernel)
    - UNIX의 가장 핵심적인 부분
    - **컴퓨터가 부팅될 때 주기억장치에 적재된 후 상주하면서 실행**
    - 프로그램과 하드웨어 간의 인터페이스 역할
    - 프로세스 관리, 기억장치 관리, 파일 관리, 프로세스간 통신 등 여러 기능 수행
- 쉘 (Shell)
    - **사용자 명령어를 인식하여 프로그램을 호출하고 명령을 수행하는 명령어 해석기**
    - 시스템과 사용자 간의 인터페이스 역할
    - 주기억장치에 상주하지 않고, 보조 기억장치에서 교체 처리 가능
    - 파이프라인 기능을 지원하고 입출력 재지정을 통해 출렵과 입력의 방향 변경 가능
- Utility Program
    - 사용자가 작성한 응용 프로그램을 처리하는 데 사용
    - *ex) 에디터, 컴파일러, 인터프리터, 디버거 등*

#### LINUX의 개요 및 특징
- 1991년 *Linux Torvalds* 가 UNIX를 기반으로 개발한 운영체제
- 프로그램 소스 코드가 무료로 공개되어 있음
- UNIX와 완벽하게 호환되며, 대부분의 특징이 UNIX와 동일

---

### 144. 기억장치 관리의 개요
#### 기억장치 계층 구조의 특징
![image](https://user-images.githubusercontent.com/46131688/109523909-3b920900-7af3-11eb-9af7-efbe328d391c.png)

(출처 - [티스토리](https://wondong2.tistory.com/19))

- 주기억장치는 자신의 주소를 갖는 워드 또는 바이트들로 구성되어 있으며, **주소를 이용하여 엑세스할 수 있음**
- 레지스터, 캐시, 주기억장치의 프로그램과 데이터는 CPU가 직접 엑세스 가능
- 보조기억장치에 있는 프로그램과 데이터는 CPU가 직접 엑세스 불가 (**주기억장치에 적재된 후 엑세스 가능**)

#### 기억장치 관리 전략의 개요
- **보조기억장치의 프로그램이나 데이터를 주기억장치에 적재시키는 시기, 적재 위치 등을 지정하여 한정된 주기억장치의 공간을 효율적으로 사용하기 위한 것**
- 전략
    - 반입 전략 / 배치 전략 / 교체 전략

#### 반입 (Fetch) 전략
- 보조기억장치에 보관중인 프로그램이나 데이터를 **언제 주기억장치로 적재할 것인지 결정**
- 요구 반입 (Demand Fetch)
    - 실행중인 프로그램이 특정 프로그램의 참조를 요구할 때 적재
- 예상 반입 (Anticipatory Fetch)
    - 실행중인 프로그램에 의해 참조될 프로그램을 미리 예상하여 적재

#### 배치 (Placement) 전략
- 새로 반입되는 프로그램이나 데이터를 **주기억장치 어디에 위치시킬 것인지 결정**
- 최초 적합 (First Fit)
    - 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중 첫 번째 분할 영역에 배치
- 최적 적합 (Best Fit)
    - 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중 단편화를 가장 작게 남기는 영역에 배치
- 최악 적합 (Worst Fit)
    - 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중 단편화를 가장 많이 남기는 영역에 배치

#### 교체 (Replacement) 전략
- 주기억장치의 이미 사용되고 있는 영역 중에서 **어느 영역을 교체하여 사용할 것인지 결정**
- *ex) FIFO / OPT / LRU / LFU 등*

---

### 145. 주기억장치 할당 기법
#### 주기억장치 할당의 개념
- 프로그램이나 데이터를 실행시키기 위해 주기억장치에 어떻게 할당할 것인지에 대한 내용
- *연속 할당 기법*
    - 단일 분할 할당 기법 : 오버레이, 스와핑
    - 다중 분할 할당 기법 : 고정 분할 할당 기법, 동적 분할 할당 기법
- *분할 할당 기법*
    - 페이징 기법
    - 세그먼테이션 기법

#### 단일 분할 할당 기법
- **주기억장치를 운영체제 영역과 사용자 영역으로 나누어 한 순간에는 오직 한 명의 사용자만이 사용자 영역을 사용하는 기법**
- 가장 단순한 기법으로 초기 운영체제에서 많이 사용
- **운영체제 영역과 사용자 영역을 구분하는 경계 레지스터 (Boundary Register) 사용**
- 프로그램 크기가 작을 경우 사용자 영역이 낭비될 수 있음
- *오버레이 (Overlay) 기법*
    - 주기억장치보다 큰 사용자 프로그램을 실행하기 위한 기법
    - 보조기억장치에 저장된 하나의 프로그램을 여러 조각으로 분할한 후 필요한 조각을 차례로 주기억장치에 적재
    - **주기억장치의 공간이 부족하면 적재된 프로그램 조각 중 불필요한 조각에 새로운 프로그램 조각을 중첩하여 적재**
- *스와핑 (Swapping) 기법*
    - 하나의 프로그램 전체를 주기억장치에 할당하여 사용하다 필요에 따라 다른 프로그램과 교체하는 기법
    - 하나의 사용자 프로그램이 완료될 때까지 교체 과정을 여러번 수행할 수 있음
    - Swap Out : 주기억장치에 있는 프로그램이 보조기억장치로 이동되는 것
    - Swap In : 보조기억장치에 있는 프로그램이 주기억장치로 이동되는 것

#### 다중 분할 할당 기법
- *고정 분할 할당 (MFT, Multiple contiguous Fixed parTition allocation) 기법* (= 정적 할당 기법)
    - 프로그램 할당 전 운영체제가 주기억장치의 사용자 영역을 여러 개의 고정된 크기로 분할하고 각 영역에 할당하여 수행하는 기법
    - 프로그램 전체가 주기억장치에 위치해야함
    - 내부 단편화 및 외부 단편화가 발생하여 주기억장치의 낭비가 많음
- *가변 분할 할당 (MVT, Multiple contiguous Variable parTition allocation) 기법* (= 동적 할당 기법)
    - **고정 분할 할당 기법의 단편화를 줄이기 위한 것**
    - 프로그램을 주기억장치에 적재하면서 필요한 만큼의 크기로 영역 분할
    - 주기억장치를 효율적으로 사용할 수 있으며, 다중 프로그래밍의 정도를 높일 수 있음

---

### 146. 가상기억장치 구현 기법 / 페이지 교체 알고리즘
#### 가상기억장치의 개요
- 보조기억장치 일부를 주기억장치처럼 사용하는 것으로, **용량이 작은 주기억장치를 마치 큰 용량을 가진 것처럼 사용하는 기법**
- 프로그램을 작은 블록 단위로 나누어서 가상기억장치에 보관해 놓고, 프로그램 실행 시 요구되는 블록만 주기억장치에 불연속적으로 할당
- 주기억장치의 이용률과 다중 프로그래밍의 효율을 높일 수 있음
- **가상기억장치의 주소를 주기억장치의 주소로 바꾸는 주소 변환 작업 필요**
- 구현 방법
    - 페이징 기법
    - 세그먼테이션 기법

#### 페이징 (Paging) 기법
- **가상기억장치에 보관되어 있는 프로그램과 주기억장치의 영역을 동일한 크기로 나눈** 후 주기억장치 영역에 적재시켜 실행
- 페이지 : 프로그램을 일정한 크기로 나눈 단위
- 페이지 프레임 : 페이지 크기로 일정하게 나누어진 주기억장치의 단위
- 외부 단편화는 발생하지 않으나 내부 단편화는 발생할 수 있음
- **주소 변환을 위해 페이지 위치 정보를 갖고 있는 페이지 맵 테이블 필요**

#### 세그먼테이션 (Segmentation) 기법
- **가상기억장치에 보관되어 있는 프로그램을 다양한 크기의 논리적인 단위로 나눈** 후 주기억장치 영역에 적재시켜 실행
- 세그먼트 : 프로그램을 배열이나 함수 등과 같은 논리적인 크기로 나눈 단위
- 내부 단편화는 발생하지 않으나 외부 단편화는 발생할 수 있음
- **주소 변환을 위해 세그먼트 위치 정보를 갖고 있는 세그먼트 맵 테이블 필요**

#### 페이지 교체 알고리즘
- 페이지 부재 시 가상기억장치의 필요한 페이지를 주기억장치에 적재해야 함
- 이때 주기억장치의 모든 페이지 프레임이 사용중이면 어떤 페이지 프레임을 교체할 것인지를 결정하는 기법
- *OPT* (OPTimal replacement, 최적 교체)
    - **앞으로 가장 오랫동안 사용하지 않을 페이지를 교체하는 기법**
    - 페이지 부재 횟수가 가장 적게 발생하는 효율적인 알고리즘
- *FIFO* (First In First Out)
    - **가장 오래 있었던 페이지를 교체하는 기법**
- *LRU* (Least Recently Used)
    - **최근에 가장 오랫동안 사용하지 않은 페이지를 교체하는 기법**
    - 즉, 가장 오래 전에 사용된 페이지를 교체
- *LFU* (Least Frequently Used)
    - **사용 빈도가 가장 적은 페이지를 교체하는 기법**
    - 활발하게 사용되는 페이지는 사용 횟수가 많아 교체되지 않고 사용
- *NUR* (Not Used Recently)
    - **최근에 사용하지 않은 페이지를 교체하는 기법** (LRU와 비슷)
    - 최근 사용 여부를 확인하기 위해 각 페이지마다 참조 비트와 변형 비트 사용
- *SCR* (Second Chance Replacement, 2차 기회 교체)
    - **가장 오랫동안 주기억장치에 있던 페이지 중 자주 사용되는 페이지의 교체를 방지하기 위한 것**
    - FIFO 기법의 단점을 보완

---

### 147. 가상기억장치 기타 관리 사항
#### 페이지 크기
- 페이지 크기가 작을 경우
    - **페이지 단편화가 감소되고, 한 개의 페이지를 주기억장치로 이동하는 시간이 줄어듬**
    - Locality에 더 일치할 수 있기 때문에 기억장치 효율이 높아짐
    - **페이지 정보를 갖는 페이지 맵 테이블 크기가 커지고, 매핑 속도가 늦어짐**
    - 디스크 접근 횟수가 많아져 전체적인 입출력 시간이 늘어남
- 페이지 크기가 클 경우
    - 페이지 맵 테이블의 크기가 작아지고, 캐핑 속도가 빨라짐
    - 페이지 단편화가 증가되고, 한 개의 페이지를 주기억장치로 이동하는 시간이 늘어남
    - **프로세스 수행에 불필요한 내용까지도 주기억장치에 적재될 수 있음**

#### Locality
- Locality는 **주기억장치를 참조할 때 일부 페이지만 집중적으로 참조하는 성질이 있다는 이론**
- 스래싱을 방지하기 위한 워킹 셋 이론의 기반
- 프로세스가 집중적으로 사용하는 페이지를 알아내는 방법 중 하나
- Locality의 종류
    - 시간 구역성 (Temporal Locality)
        - 프로세스가 실행되면서 **하나의 페이지를 일정 시간 동안 집중적으로 액세스**하는 현상
        - **한 번 참조한 페이지는 가까운 시간 내 계속 참조할 가능성이 높음**
        - *ex) Loop, Stack, Sub Routine, Counting*
    - 공간 구역성 (Spatial Locality)
        - 프로세스 실행 시 **일정 위치의 페이지를 집중적으로 액세스**하는 현상
        - **하나의 페이지를 참조하면 그 근처의 페이지를 계속 참조할 가능성이 높음**
        - *ex) 배열 순회, 순차적 코드의 실행*

#### 워킹 셋 (Working Set)
- 프로세스가 일정 시간 동안 자주 참조하는 페이지들의 집합
- **자주 참조되는 워킹 셋을 주기억장치에 상주시킴으로써 페이지 부재 및 페이지 교체 현상이 줄어들어 기억장치 사용이 안정됨**
- 워킹 셋은 시간에 따라 변경됨

#### 페이지 부재 빈도 (PFF, Page Fault Frequency) 방식
- 페이지 부재 : 프로세스 실행 시 참조할 페이지가 주기억장치에 없는 현상
- 페이지 부재율에 따라 주기억장치에 있는 페이지 프레임 수를 늘리거나 줄여 페이지 부재율을 적정 수준으로 유지하는 방식

#### 프리페이징 (Prepaging)
- 처음의 과도한 페이지 부재를 방지하기 위해 **필요할 것 같은 모든 페이지를 한꺼번에 페이지 프레임에 적재하는 기법**

#### 스래싱 (Thrashing)
- **프로세스 처리 시간보다 페이지 교체에 소요되는 시간이 더 많아지는 현상**
- 스래싱 현상 방지 방법
    - 다중 프로그래밍 정도를 적정 수준으로 유지
    - 페이지 부재 빈도를 조절하여 사용
    - 워킹 셋 유지

---

### 148. 프로세스의 개요
#### 프로세스 (Process)의 정의
- **실행중인 프로그램** (= 작업, 태스크)
- PCB를 가진 프로그램
- 실기억장치에 저장된 프로그램
- 프로세서가 할당되는 실체
- 프로시저가 활동중인 것
- 비동기적 행위를 일으키는 주체

#### PCB (Process Control Block, 프로세스 제어 블록)
- PCB는 **운영체제가 프로세스에 대한 중요한 정보를 저장해 놓는 곳** (= Task Control Block, Job Control Block)
- 각 프로세스가 생성될 때마다 고유의 PCB가 생성되고, 프로세스 완료 시 제거됨
- **PCB에 저장되어 있는 정보**
    - 프로세스의 현재 상태 : 준비, 대기, 실행 등 프로세스 상태
    - 포인터
        - 부모 프로세스에 대한 포인터
        - 자식 프로세스에 대한 포인터
        - 프로세스가 위치한 메모리에 대한 포인터 : 현재 프로세스가 위치한 주소 기억
        - 할당된 자원에 대한 포인터 : 프로세스에 할당된 각 자원에 대한 주소 기억
    - 프로세스 고유 식별자
    - 스케줄링 및 프로세스의 우선순위
    - CPU 레지스터 정보
    - 주기억장치 관리 정보
    - 입출력 사앹 정보
    - 계정 정보 : CPU 사용 시간, 한정된 시간

#### 프로세스 상태 전이
- 프로세스가 시스템 내에 존재하는 동안 프로세스 상태가 변하는 것을 의미

![image](https://user-images.githubusercontent.com/46131688/109534414-a8f76700-7afe-11eb-803d-842c0de6d45e.png)

(출처 - [티스토리](https://sommda.tistory.com/25))

- 제출 (Submit)
    - 작업을 처리하기 위해 사용자가 작업을 시스템에 제출한 상태
- 접수 (Hold) 
    - 제출된 작업이 스풀 공간인 디스크 할당 위치에 저장된 상태
- 준비 (Ready)
    - 프로세스가 프로세서를 할당받기 위해 기다리고 있는 상태
    - **프로세스는 준비상태 큐에서 실행 준비**
    - 접수 상태에서 준비 상태로의 전이는 Job Scheduler에 의해 수행
- 실행 (Run)
    - 준비상태 큐에 있는 프로세스가 프로세서를 할당받아 실행되는 상태
    - 프로세스 수행이 완료되기 전에 Timer Run Out되면 프로세스는 준비 상태로 돌아감
    - 실행중인 프로세스에 입출력 처리가 필요하면 대기 상태로 전이됨
    - 준비 상태에서 실행 상태로의 전이는 CPU Scheduler에 의해 실행
- 대기 (Wait), 보류, 블록 (Block)
    - 프로세스에 입출력 처리가 필요하면 현재 실행 중인 프로세스가 중단되고, 처리가 완료될 때까지 대기하고 있는 상태
- 종료 (Terminated, Exit)
    - 프로세스 실행이 끝나고 프로세스 할당이 해제된 상태

#### 프로세스 상태 전이 관련 용어
- Dispatch
    - 준비 상태에서 대기하고 있는 프로세스 중 하나가 프로세서를 할당받아 실행 상태로 전이되는 과정
- Wake Up
    - 입출력 작업이 완료되어 프로세스가 대기 상태에서 준비 상태로 전이되는 과정
- Spooling
    - 상대적으로 느린 입출력장치의 처리 속도를 보완하기 위해 **입출력할 데이터를 나중에 한꺼번에 처리하기 위해 디스크에 저장하는 과정**
- 교통량 제어기 (Traffic Controller) 
    - 프로세스 상태에 대한 조사와 통보 담당

#### 스레드 (Thread)
- 프로세스 내에서의 작업 단위로서 **시스템의 여러 자원을 할당받아 실행하는 프로그램의 단위**
- 단일 스레드 : 하나의 프로세스에 하나의 스레드가 존재하는 경우
- 다중 스레드 : 하나의 프로세스에 하나 이상의 스레드가 존재하는 경우
- 스레드 기반 시스템에서 스레드는 독립적인 스케줄링의 최소 단위로서 프로세스 역할을 담당
- 스레드 분류
    - 사용자 수준의 스레드
        - 사용자가 만든 라이브러리를 사용하여 스레드 운용
        - 속도는 빠르지만 구현이 어려움
    - 커널 수준의 스레드
        - 운영체제의 커널에 의해 스레드 운용
        - 구현이 쉽지만 속도가 느림
- 스레드 사용의 장점
    - 하나의 프로세스를 여러 개의 스레드로 생성하여 병행성 증진
    - 처리율 향상, 응답 시간 단축
    - 프로세스들 간의 통신 향상
    - **실행 환경을 공유시켜 기억장소의 낭비가 줄어듬**

---

### 149. 스케줄링
#### 스케줄링 (Scheduling)의 개요
- 스케줄링은 **프로세스가 생성되어 실행될 때 필요한 여러 자원을 해당 프로세스에게 할당하는 작업**
- 스케줄링 종류
    - 장기 스케줄링 (= 작업 스케줄링, 상위 스케줄링)
        - **어떤 프로세스가 시스템 자원을 차지할 수 있도록 할 것인가**를 결정하여 준비상태 큐로 보내는 작업
    - 중기 스케일링 
        - **어떤 프로세스들이 CPU를 할당받을 것인지** 결정하는 작업
    - 단기 스케줄링 (= 프로세서 스케줄링, 하위 스케줄링)
        - **프로세스가 실행되기 위해 CPU를 할당받는 시기**와 특정 프로세스를 지정하는 작업
- 문맥 교환 (Context Switching)
    - 하나의 프로세스에서 다른 프로세스로 CPU가 할당되는 과정에서 발생
    - **현재 CPU가 할당된 프로세스의 상태 정보를 저장하고, 새로운 프로세스의 상태 정보를 설정한 후 CPU를 할당하여 실행되도록 하는 작업**

#### 스케줄링의 목적
- 공정성 : 모든 프로세스에 공정하게 할당
- 처리율 증가 : 단위 시간당 프로세스를 처리하는 비율을 증가시킴
- CPU 이용률 증가 : CPU 낭비 시간을 줄이고, 순수하게 프로세스를 실행하는 데 사용되는 시간 비율을 증가시킴
- 우선순위 제도 : 우선순위가 높은 프로세스 먼저 실행
- 오버헤드 최소화
- 응답 시간 최소화
- 반환 시간 최소화
- 대기 시간 최소화 : 프로세스가 준비상태 큐에서 대기하는 시간을 초쇠화
- 균형 있는 자원의 사용 : 메모리, 입출력장치 등의 자원을 균형있게 사용
- 무한 연기 회피 : 자원을 사용하기 위해 무한정 연기되는 상태를 회피

#### 프로세스 스케줄링 기법
- 비선점 (Non-Preemptive) 스케줄링
    - **이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없는 스케줄링 기법**
    - 프로세스가 CPU를 할당받으면 해당 프로세스가 완료될 때까지 CPU 사용
    - 프로세스 응답 시간의 예측이 용이하며, **일괄 처리 방식에 적합**
    - 중요한 짧은 작업이 중요하지 않은 긴 작업을 기다리는 경우 발생
    - *ex) FCFS, SJF, 우선순위, HRN 등*
- 선점 (Preemptive) 스케줄링
    - **하나의 프로세스가 CPU를 할당받ㅇ ㅏ실행하고 있을 때 우선순위가 높은 다른 프로세스가 빼앗아 사용할 수 있는 스케줄링 기법**
    - 주로 빠른 응답 시간을 요구하는 대화식 시분할 시스템에 사용
    - 많은 오버헤드 초래
    - *ex) Round Robin, SRT, 선점 우선순위, 다단계 큐 등*

---

### 150. 환경 변수
#### 환경 변수의 개요
- 환경 변수란 시스템 소프트웨어 동작에 영향을 미치는 동적인 값들의 모임
- 환경 변수는 변수명과 값으로 구성
- 시스템의 기본 정보를 저장하며 **자식 프로세스에 상속됨**
- 구분
    - 시스템 환경 변수 : 시스템 전반에 걸쳐 적용
    - 사용자 환경 변수 : 사용자 계정 내에서만 적용

#### 모든 환경 변수와 값 표시
- Windows : *set*
- UNIX / LINUX : *set / env / printenv*

---

### 151. 운영체제 기본 명령어
#### 운영체제 기본 명령어의 개요
- CLI (Command Line Interface)
    - 키보드로 명령어를 직접 입력하여 작업 수행
- GUI (Graphic User Interface)
    - 마우스로 아이콘이나 메뉴를 선택하여 작업 수행

#### Windows 기본 명령어
- DIR : 파일 목록 표시
- COPY : 파일 복사
- TYPE : 파일 내용 포시
- REN : 파일 이름 변경
- DEL : 파일 삭제
- MD : 디렉터리 생성
- CD : 디렉터리 위치 변경
- CLS : 화면 내용 지움
- ATTRIB : 파일 속성 변경
- FIND : 파일 찾음
- CHKDSK : 디스크 상태 점검
- FORMAT : 디스크 표면을 트랙과 섹터로 나누어 초기화
- MOVE : 파일 이동

#### UNIX / LINUX 기본 명령어
- cat : 파일 내용을 화면에 표시
- chdir : 현재 사용할 디렉터리 위치를 변경
- chmod : 파일의 보호 모드 설정
- chown : 소유자 변경
- exec : 새로운 프로세스 수행
- fork : 새로운 프로세스 생성
- fsck : 파일 시스템을 검사하고 보수
- getpid : 자신의 프로세스 아이디
- getppid : 부모 프로세스 아이디
- mount/unmount : 파일 시스템 마운팅 / 마운팅 해제

---

### 152. 인터넷
#### 인터넷 (Internet)의 개요
- 인터넷이란 **TCP/IP 프로토콜을 기반으로 전 세계 수많은 컴퓨터와 네트워크들이 연결된 광범위한 컴퓨터 통신망**
- 인터넷은 유닉스 운영체제 기반
- 인터넷에 연결된 모든 컴퓨터는 고유한 IP 주소를 가짐
- 컴퓨터 또는 네트워크를 서로 연결하기 위해서는 브리지, 라우터, 게이트웨이 사용

#### IP 주소 (Internet Protocol Address)
- IP 주소는 **인터넷에 연결된 모든 컴퓨터 자원을 구분하기 위한 고유 주소**
- 숫자로 8비트씩 4부분, 총 32비트로 구성
- *A Class*
    - 국가나 대형 통신망에 사용 (0~127로 시작)
    - 8비트 네트워크 부분 + 24비트 호스트 부분
- *B Class*
    - 중대형 통신망에 사용 (128~191로 시작)
    - 16비트 네트워크 부분 + 16비트 호스트 부분
- *C Class*
    - 소규모 통신망에 사용 (193~223으로 시작)
    - 24비트 네트워크 부분 + 8비트 호스트 부분
- *D Class*
    - 멀티캐스트 용으로 사용 (224~239로 시작)
- *E Class*
    - 실험적 주소이며 공용되지 않음

#### 서브네팅 (Subnetting)
- **할당된 네트워크 주소를 다시 여러 개의 작은 네트워크로 나누어 사용하는 것**
- 서브넷 마스크 : 32비트의 IP 주소 중 네트워크 주소와 호스트 주소를 구분하기 위한 비트

#### IPv6 (Internet Protocol version 6)의 개요
- 현재 사용하고 있는 IPv4의 주소 부족 문제를 해결하기 위해 개발
- **128비트의 긴 주소를 사용하여 주소 부족 문제를 해결**하며, 자료 전송 속도가 빠름
- 인증성, 기밀성, 데이터 무결성의 지원으로 보안 문제 해결
- 주소의 확장성, 융통성, 연동성이 뛰어나며 실시간 흐름 제어로 향상된 멀티미디어 기능 제공

#### IPv6의 구성
- 16비트씩 8부분, 총 128비트로 구성
- 구성
    - 유니캐스트 (Unicast) : 단일 송신자와 단일 수신자 간의 통신 (1 대 1 통신)
    - 멀티캐스트 (Multicast) : 단일 송신자와 다중 수신자 간의 통신 (1 대 다 통신)
    - 애니캐스트 (Anycast) : **단일 송신자와 가장 가까이 있는 단일 수신자 간의 통신** (1 대 1 통신)

#### 도메인 네임 (Domain Name)
- 숫자로 된 IP 주소를 **사람이 이해하기 쉬운 문자 형태로 표현한 것**
- *호스트 컴퓨터 이름.소속 기관 이름. 소속 기관의 종류. 소속 국가명* 
- 왼쪽에서 오른쪽으로 갈수록 상위 도메인
- DNS (Domain Name System)
    - 도메인 네임을 컴퓨터가 이해할 수 있는 IP 주소로 변환하는 역할

---

### 153. OSI 참조 모델
#### OSI (Open System Interconnection) 참조 모델의 개요
- OSI는 **시스템 간 원활한 통신을 위해 ISO에서 제안한 통신 규약 (Protocol)**
- 개방형 시스템 (Open System) 간 데이터 통신 시 필요한 장비 및 처리 방법 등을 7단계로 표준화하여 규정
- 하위 계층 : 물리 계층 → 데이터링크 계층 → 네트워크 계층
- 상위 계층 : 전송 계층 → 세션 계층 → 표현 계층 → 응용 계층

#### OSI 참조 모델에서의 데이터 단위
- 프로토콜 데이터 단위 (PDU, Protocol Data Unit)
    - **동일 계층 간에 교환되는 정보의 단위**
    - 물리 계층 : 비트
    - 데이터링크 계층 : 프레임
    - 네트워크 계층 : 패킷
    - 전송 계층 : 세그먼트
    - 세션, 표현, 응용 계층 : 메시지
- 서비스 데이터 단위 (SDU, Service Data Unit)
    - 서비스 접근점 (SAP)을 통해 상하위 계층끼리 주고받는 정보의 단위

#### 물리 계층 (Physical Layer)
- **전송에 필요한 두 장치 간의 실제 접속과 절단 등 기계적, 전기적, 절차적 특성에 대한 규칙을 정의**
- 물리적 전송 매체와 전송 신호 방식을 정의
- 표준 : RS-232C, X.21 등
- 관련 장비 : 리피터, 허브

#### 데이터링크 계층 (Data Link Layer)
- **두 개의 인접한 개방 시스템들 간에 신뢰성 있고 효율적인 정보 전송**
- 송신 측과 수신 측의 속도 차리를 해결하기 위한 *흐름 제어 기능*
- 프레임의 시작과 끝을 구분하기 위한 *프레임 동기화 기능*
- 오류의 검출과 회복을 위한 *오류 제어 기능*
- 프레임의 순서적 전송을 위한 *순서 제어 기능*
- 표준 : HDLC, LAPB, LLC, MAC, PPP 등
- 관련 장비 : 랜카드, 브리지, 스위치

#### 네트워크 계층 (Network Layer, 망 계층)
- **개방 시스템들 간 네트워크 연결을 관리하는 기능과 데이터 교환 및 중계 기능**
- 경로 설정 (Routing), 트래픽 제어, 패킷 정보 전송 수행
- 표준 : X.25, IP 등
- 관련 장비 : 라우터

#### 전송 계층 (Transport Layer)
- **논리적 안정과 균일한 데이터 전송 서비스를 제공함으로써 End-to-End 간 투명한 데이터 전송**
- OSI 하위 3계층과 상위 3계층의 인터페이스 담당
- 주소 설정, 다중화, 오류 제어 수행
- 표준 : TCP, UDP 등
- 관련 장비 : 게이트웨이

#### 세션 계층 (Session Layer)
- **송수신 측 간의 관련성을 유지하고 대화 제어 담당**
- 대화 구성 및 동기 제어, 데이터 교환 관리 기능
- 동기점 : 송수신 측 간의 대화 동기를 위해 전송하는 정보의 일정한 부분에 체크점을 두는 것

#### 표현 계층 (Presentation Layer)
- **응용 계층으로부터 받은 데이터를 세션 계층에, 세션 계층에서 받은 데이터를 응용 계층에 맞게 변환하는 기능**
- 서로 다른 데이터 표현 형태를 갖는 시스템 간 상호 접속을 위해 필요한 계층
- 코드 변환, 데이터 암호화, 데이터 압축, 문맥 관리 기능

#### 응용 계층 (Application Layer)
- 사용자가 OSI 환경에 접근할 수 있도록 서비스 제공**

---

### 154. 네트워크 관련 장비
#### 네트워크 인터페이스 카드 (NIC, Network Interface Card)
- 컴퓨터와 컴퓨터 또는 컴퓨터와 네트워크를 연결하는 장치
- **정보 전송 시 정보가 케이블을 통해 전송될 수 있도록 정보 형태를 변경**

#### 허브 (Hub)
- 한 사무실이나 가까운 거리의 컴퓨터들을 연결하는 장치로, **신호 증폭 기능을 하는 리피터 역할도 포함**
- *더미 허브* (Dummy Hub)
    - 네트워크에 흐르는 모든 데이터를 단순히 연결하는 기능만 제공
    - LAN이 보유한 대역폭을 컴퓨터 수만큼 나누어 제공
- *스위칭 허브* (Switching Hub)
    - 네트워크상에 흐르는 데이터 유무 및 흐름을 제어하여 **각각의 노드가 허브의 최대 대역폭을 사용**

#### 리피터 (Repeater)
- **전송되는 신호가 원래 형태와 다르게 왜곡되거나 약해질 경우 원래의 신호 형태로 재생하여 다시 전송하는 역할**
- 물리 계층에서 동작

#### 브리지 (Bridge)
- LAN과 LAN 또는 LAN 안에서의 컴퓨터 그룹을 연결하는 기능
- 네트워크 상의 많은 단말기들에 의해 발생되는 트래픽 병목 현상을 줄일 수 있음
- 데이터링크 계층 중 MAC (Media Access Control) 계층에서 사용

#### 스위치 (Switch)
- **브리지와 같이 LAN과 LAN을 연결하여 훨씬 더 큰 LAN을 만드는 장치**
- 하드웨어 기반으로 처리하기 때문에 전송 속도가 빠름
- 데이터링크 계층에서 동작

#### 라우터 (Router)
- **LAN과 LAN의 연결 기능에 데이터 전송의 최적 경로를 선택할 수 있는 기능이 추가된 것**
- 네트워크 계층에서 동작

#### 게이트웨이 (Gateway)
- 전 계층의 프로토콜 구조가 다른 네트워크 연결을 수행
- 세션 계층, 표현 계층, 응용 계층 간을 연결하여 데이터 형식 변환, 주소 변환, 프로토콜 변환 등 수행

---

### 155. 프로토콜의 개념
#### 프로토콜 (Protocol)의 정의
- **서로 다른 기기들 간의 데이터 교환을 원할하게 수행할 수 있도록 표준화시켜 놓은 통신 규약**

#### 프로토콜의 기본 요소
- 구분 (Syntax) : 전송하고자 하는 데이터 형식, 부호화, 신호 레벨 등을 규정
- 의미 (Semantics) : 두 기기 간 효율적이고 정확한 정보 전송을 위한 협조 사항과 오류 관리를 위한 제어 정보를 규정
- 시간 (Timing) : 두 기기 간 통신 속도, 메시지 순서 제어 등을 규정

#### 프로토콜의 기능
- 단편화와 재결합
    - 단편화 (Fragmentation) : 송신 측에서 전송할 데이터를 전송에 알맞은 작은 블록으로 자르는 작업
    - 재결합 (Reassembly) : 수신 측에서 단편화된 블록을 원래 데이터로 모으는 것
    - **단편화 시 전송 시간이 빠르고 통신 중의 오류를 효과적으로 제어**
- 캡슐화 
    - 단편화된 데이터에 송수신지 주소, 오류 검출 코드, 프로토콜 제어 정보 등의 정보를 부가하는 것
    - **정보 데이터를 오류 없이 정확하게 전송하기 위해 캡슐화 수행**
- 흐름 제어 (Flow Control)
    - 수신 측 처리 능력에 따라 송신하는 데이터의 전송량이나 전송 속도를 조절하는 기능
    - Stop-and-Wait / Sliding Window 방식
- 오류 제어 (Error Control)
    - 전송중에 발생하는 오류를 검출하여 정보의 파손에 대비하는 기능
- 동기화 (Synchronization)
    - 송수신 측이 같은 상태를 유지하도록 타이밍을 맞추는 기능
- 순서 제어 (Sequencing)
    - **PDU에 전송 순서를 부여하는 기능** (연결 위주의 데이터 전송 방식에만 사용)
    - **송신 데이터를 순서대로 전송함으로써 흐름 제어 및 오류 제어를 용이하게함**
- 주소 지정 (Addressing)
    - 데이터가 목적지까지 전송될 수 있도록 목적지 이름, 주소, 경로를 부여하는 기능
- 다중화 (Multiplexing)
    - 한 개의 통신 회선을 여러 가입자들이 동시에 사용하도록 하는 기능
- 경로 제어 (Routing)
    - 송신 경로 중에서 최적의 패킷 교환 경로를 설정하는 기능
- 전송 서비스
    - 전송하려는 데이터가 사용하도록 하는 별도의 부가 서비스

---

### 156. TCP/IP
#### TCP/IP의 개요 (Transmission Control Protocol / Internet Protocol)
- **인터넷에 연결된 서로 다른 기종의 컴퓨터들이 데이터를 주고받을 수 있도록 하는 표준 프로토콜**
- TCP
    - OSI 7계층의 **전송 계층**에 해당
    - 신뢰성 있는 연결형 서비스를 제공
    - 패킷의 다중화, 순서 제어, 오류 제어, 흐름 제어 기능을 제공
    - 스트림 전송 기능 제공
- IP
    - OST 7계층의 **네트워크 계층**에 해당
    - 데이터그램을 기반으로 하는 비연결형 서비스 제공
    - 패킷의 분해/조립, 주소 지정, 경로 선택 기능 제공

#### TCP/IP의 구조
- 응용 계층 (OSI 응용, 표현, 세션 계층)
    - 응용 프로그램 간의 데이터 송수신 제공
    - *ex) TELNET, FTP, SMTP, DNS, HTTP 등*
- 전송 계층 (OSI 전송 계층)
    - 호스트들 간의 신뢰성 있는 통신 제공
    - *ex) TCP, UDP*
- 인터넷 계층 (OSI 네트워크 계층)
    - 데이터 전송을 위한 주소 지정, 경로 설정을 제공
    - *ex) IP, ICMP, ARP*
- 네트워크 액세스 계층 (OSI 데이터링크, 물리 계층)
    - 실제 데이터를 송수신하는 역할
    - *ex) Ethernet, IEEE 802, HDLC, RS-232C 등*

---

#### 참고
- [시나공 정보처리기사 필기 책](https://book.naver.com/bookdb/book_detail.nhn?bid=15766742)
